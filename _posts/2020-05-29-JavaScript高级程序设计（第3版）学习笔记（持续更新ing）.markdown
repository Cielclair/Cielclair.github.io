---
layout: post
title: JavaScript高级程序设计（第3版）学习笔记（持续更新ing）
---



# 作用域

- **执行环境（execution context）**是JavaScript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有一个与之关联的**变量对象（variable object）**，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。
- 某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。
  - 每个函数都有自己的**执行环境**。当执行流进入一个函数时，函数的环境就会被推入一个**环境栈**中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。
- 当代码在一个环境中执行时，会创建**变量对象**的一个**作用域链（scope chain）**。
  - 作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。
  - 作用域链的前端，始终都是当前执行的代码所在环境的**变量对象**。
  - 如果这个环境是函数，则将其**活动对象（activation object）**作为变量对象。
    - 活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。
    - 作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。
    - 这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。
- **标识符解析**是沿着作用域链一级一级地搜索标识符的过程。
  - 所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。
  - 搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）



- 在局部作用域中定义的变量可以在局部环境中与全局变量互换使用
- 内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。
- 每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。




# 函数

- 理解ECMAScript函数的参数：

  - ECMAScript中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数。

    - 在函数体内可以通过 `arguments` 对象来访问这个参数数组，从而获取传递给函数的每一个参数。

    - `arguments` 对象可以使用方括号语法访问它的每一个元素（即第一个元素是 `arguments[0]`，第二个元素是`arguments[1]`，以此类推），使用 `length` 属性来确定传递进来多少个参数。

      > 可以在函数体内不显式地使用命名参数
      >
      > ```javascript
      > function sayHi(){
      > alert("Hello" + arguments[0] + "," + arguments[1]);
      > }
      > ```
      >
      > => 这个事实说明了ECMAScript函数的一个重要特点：命名的参数只提供便利，但不是必需的

    - `arguments` 对象只是与数组类似（它并不是 `Array` 的实例）

    - `arguments` 对象可以与*命名参数*一起使用

    - `arguments` 对象的值永远与对应*命名参数*的值保持同步

      > 这并不是说读取这两个值会访问相同的内存空间；
      >
      > 它们的内存空间是独立的，但它们的值会同步。

  - **ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。**

    > 访问变量有按值和按引用两种方式，而参数只能按值传递

- 函数实际上是对象。

  - 每个函数都是 `Function` 类型的实例，而且都与其他引用类型一样具有属性和方法。
  - 由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。

- **函数声明**语法 VS **函数表达式**定义函数

  - 函数声明

    > ```javascript
    > function sum (num1, num2) {
    > return num1 + num2;
    > }
    > ```

  - 函数表达式（匿名函数）【并非函数，实际为一个变量，只是其值为函数】

    > ```javascript
    > var sum = function (num1, num2) { // 在使用函数表达式定义函数时，没有必要使用函数名，通过变量即可以引用函数；
    > return num1 + num2;
    > }; // 还要注意函数末尾有一个分号，就像声明其他变量时一样
    > ```

  - **在向执行环境中加载数据时，解析器会率先读取函数声明，并使其在执行任何代码之前可用**；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。

    > ```javascript
    > alert (sum(10,10));
    > function sum(num1, num2) {
    > return num1 + num2;
    > }
    > ```
    >
    > 以上代码完全可以正常运行，是因为在代码开始执行之前，解析器就已经通过一个名为**函数声明提升（function declaration hoisting）**的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript引擎在第一遍会声明函数并将它们放到源代码树的顶部。

  - 除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。

- `Function` 构造函数可以接收任意数量的参数，但最后一个参数始终都被看成是函数体

  > ```javascript
  > var sum = new Function("num1", "num2", "return num1 + num2"); // 不推荐
  > ```
  >
  > 从技术角度讲，这是一个函数表达式。但是，不推荐使用这种方法定义函数，因为这种语法会导致解析两次代码（第一次是解析常规ECMAScript代码，第二次是解析传入构造函数中的字符串），从而影响性能。
  >
  > 不过，这种语法对于理解**"函数是对象，函数名是指针"**的概念倒是非常直观的。
  >
  > p.s. 使用不带圆括号的函数名是访问函数指针，而非调用函数。